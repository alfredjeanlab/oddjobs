## Phase 1: Data Model, Storage & CLI (DONE)
- Decision struct: id, pipeline_id, agent_id, source (question/approval/gate/error/idle), context, options[], chosen, created_at, resolved_at
- Store decisions in materialized state (new top-level map, not nested under pipeline)
- Events: DecisionCreated, DecisionResolved
- StepStatus::Waiting carries decision_id instead of bare reason string
- oj decision list — id, pipeline, age, source, summary
- oj decision show <id> — full context + numbered options
- oj decision resolve <id> [choice] [-m message] — choice picks numbered option, -m adds freeform text (nudge message, custom answer). Either or both. No choice + -m = freeform answer.
- oj decisions shorthand

## Phase 2: Decision Debug Bundle
- Write {logs_dir}/decision/{decision_id}.crumb.json on creation (same atomic-write pattern as pipeline crumbs)
- Write {logs_dir}/decision/{decision_id}.debug.txt with human-readable context snapshot (agent log tail, gate stderr, pipeline state)
- Delete crumb on resolve; keep debug.txt for post-mortem
- Orphan detection at startup: scan decision crumbs vs materialized state

## Phase 3: Escalation Decisions
- Escalation paths emit DecisionCreated with system-generated options (retry/nudge/cancel)
- Gate failures include gate command + exit code + stderr in context
- on_dead/on_idle/on_error include agent log tail in context
- Desktop notification on decision created (replaces current escalation notify)

## Phase 4: AskUserQuestion Decisions
- PreToolUse hook captures AskUserQuestion payload (question text, options)
- Answer flows back to agent via resume message or hook response

## Phase 5: Plan Approval Decisions
- PreToolUse hook captures ExitPlanMode payload (plan file contents)
- Approve/reject flows back to agent

## Phase 6: Polish
- oj status shows decision count per project
- Decision auto-expires if pipeline is cancelled externally
- oj decision list --resolved for history
